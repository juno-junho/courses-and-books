# 우아한 객체지향

의존성 : B가 바뀌었을때 A가 바뀔 가능성이 있다

의존성이 있다해서 무조건 바뀌진 않음.

B라는 클래스의 내부 구현이 변경 되더라도 A 클래스에 영향 안 줄 수 있다.

(설계를 잘하면)

의존성 : 변경에 의해서 영향을 받을 수 있는 가능성

1. 클래스 사이에 의존성
2. 패키지 사이의 의존성

1. 클래스 의존성
    1. 연관관계 (A에서 B로 이동할 수 있다) → 영구적으로 갈 수 있는 관계
    2. 의존관계 (파라미터, 리턴타입에서 해당 타입이 나오거나 메서드 안에서 그 객체 생성 시 dependency라 보면 된다.) → 협력하는 시점에 관계 맺고 헤어지는 관계
    3. 상속 관계 : 부모가 바뀌면 A가 바뀐다. → 구현이 바뀌더라도 영향 받음
    4. 실체화 관계 : 인터페이스를 implement하는 관계 → 인터페이스 operation 시그니처 바뀌었을때만 영향 받음

2. 패키지 의존성
- 패키지 A가 패키지 B에 의존한다 : B의 클래스가 바뀌면 A의 클래스가 바뀐다.
- import에 다른 패키지 이름이 나온다 → dependency가 있다.

**좋은 의존성을 관리하기 위한 규칙**

1. 양방향 의존성을 피하라.
    - B가 바뀌면 A도 바뀌고, A가 바뀌면 B도 바뀐다.
    - 원래 하나의 클래스로 봐도 되는 것을 어거지로 찢어 놓은것.
    - A와 B 사이의 관계를 항상 동기화 시켜줘야한다. 성능이슈 많이 발생하고, 버그 많이 발생한다.
    - 따라서 양방향 연관관계 피할 수 있으면 **단방향 연관관계로 바꾸기**


2. 다중성이 적은 방향을 선택하라
    - A : B가 일대 다 일때,  A에서 B 타입의 컬렉션을 인스턴스 변수로 잡거나 Collection에 대해서 dependency를 가지는 것 보다는, B에서 A타입을 인스턴스 변수로 가지는 것이 좋다.
    - Collection을 인스턴스 변수로 가지면 jpa에서는 성능이슈도 많이 발생하고, 객체 관계 유지를 위해 많은 노력이 필요하다.
    - 단방향 참조를 가지는 것이 좋다.

3. 의존성이 필요 없다면 제거하라.
- 패키지 사이의 의존성 사이클을 제거하라.
    - 패키지 사이에는 양방향 사이클이 있으면 안된다.
    - 사이클이 돈다는 것은 원래 하나의 패키지라는 것이다.

설계의 원칙은 변경이다.

협력 설계하기

주문하기 → 서로 메세지를 보낸다.

코드에 인스턴스 변수 넣거나 , 메서드에 파라미터로 넣을때 → 이 타입 객체와 이 타입의 객체는 런타임에 협력할 것이다 라는 것을 의미.

협력이라는 것을 정적인 코드로 표현해야 한다.

객체에서 관계는 **방향성이 필요하다**. 의존성이라는 것은 a가 b에 의존해. 타겟이라는 것이 필요하고 방향성이 있다 (방향성이 없는 fk와 다름) 방향성을 결정하는 것이 중요하다.

**→ 의존성의 방향이 된다.**

연관관계 : 객체 간의 영구적인 탐색구조를 잡아줘야 할때.

협력을 위해 필요한 영구적인 탐색 구조.

‘런타임에 어떻게 협력을 할거야’ 라는 것을 기반을 정해줘야한다.

Order , Shop이랑 굉장히 빈번히 협력해야 한다 → 인스턴스 변수로 잡아 두는게 낫겟다 → 연관관계로 잡아주는게 나음.

---

의존관계 : 협력을 위해 일시적으로 필요한 의존성

파라미터, 리턴타입, 지연변수.

내부에서 new로 생성..

핵심은 방향성이 중요하다. 연관관계, 의존관계를 넣는 이유가 있어야 하고, 그것은 런타임에 객체들이 어떻게 협력하느냐에 따라 달라진다.

연관관계 == 탐색 가능성.

어떤 객체가 있는데, 이 객체를 알면 다른 객체를 찾아 갈 수 있어. → 연관관계의 정의

연관관계를 잡는 것은, 두 객체간의 통로가 영구적으로 유지가 되어야해 라는 판단근거가 있어야 한다.

**일반적으로 객체 참조를 사용한다.** Order에는 OrderLineItem의 List를 인스턴스 변수로 가지고 있다.

**연관관계를 구현할 수 있는 가장 대표적인 방법 중 하나 : 객체 참조.**

→ Order를 통해서 OrderLineItem에 접근 할 수 있다.

주문하기의 협력은 Order라는 객체에 주문하기라는 메세지가 도착했을때 시작한다.

어떤 객체가 메세지를 받는다 → public 메서드로 구현된다.

**메세지를 결정하고 → 메서드를 결정하는게 맞다.**

주문이라는 것은 항상 가게, 주문 항목과 연관관계 설정 (물리적인 통로가 필요해 → 객체 참조 사용)

---

일단 처음에 절차적으로 짠다

dependency를 보면서 설계를 개선하면 원하는 구조로 가는 경우가 많다.

**→ dependency를 한번 그려보기. → 설계를 어떻게 개선해야할지에 대한 그림이 보인다.**

패키지로 레이어를 나눈다.

1. 객체 참조가 가져오는 문제점
2. 패키지 의존성 사이클의 문제점

1. 중간 객체를 이용한 의존성 사이클 끊기
- 중간 객체를 하나 생성해서 단방향으로 dependency를 만들기.
- 의존성 역전 원리 : 클래스들이 구체적인 것에 의존하지 말고 추상화에 의존해라. → 이걸로 패키지 사이클을 끊는게 나옴.
   - 추상화라고 하면 인터페이스나 추상클래스여야 한다는 선입견이 있다.
   - 하지만 추상화라는 것은, 잘 안변하는 것을 말한다.
   - 어떤 것에 비해서 어떤 것이 잘 변하지 않는다면 추상적인 것.

1. 연관관계라는 것은 어떤 객체에서 어떤 객체를 탐색 할 수 있는 것.
- 객체 참조로 구현한 연관관계의 문제점 : 두 객체 사이의 결합도가 높아진다.
   - 어디든 다 참조할 수 있다. 어디까지 조회할 것인가? 메모리상에서는 크게 문제가 안되지만 orm 같은 것을 쓰면 db로 직접 매핑시 연관관계가 있으면 어디까지..? lazy loading 이슈가 많이 생김.
   - 어디까지 읽어야 하는지, lazy loading issue 어떻게 해결해야하는지 모름.
   - **객체가 다 연결되어 있다보니, 어디 까지 읽어야 하고, 어디 까지 읽지 말아야 하는 가이드가 없는 것이 근본적인 문제**
- 객체는 그러면 어디서 부터 어디까지 수정해야 하는가? 가 문제가 된다.
   - **다른 말로, 트랜젝션 경계는 어디까지 인가? 모호해진다. DB , 인프라 매핑시 성능 문제가 생기는데, 객체 참조는 그것을 생각 안하게 만들어 버림.**
   - 요구 사항이 추가 될 수록 트랜젝션 길어진다.
- 한 트랜젝션으로 묶여 있지만, 실제로는 ADMIN, BATCH나 새로운 요구사항 추가 될 수록 트랜젝션이 몰리는 주기가 달라진다.
   - 트랜젝션 경합으로 인한 성능 저하, 응답성이 떨어지는 경우가 빈번히 발생한다.

**→ 객체 참조가 꼭 필요할까? 라는 고민을 할 수 밖에 없다.**

- **객체 참조는 모든 것을 연결시켜 버린다.**

→ 결합도가 영구적인 결합도. 가장 높은 의존성.

→ 필요한 경우 객체 참조 끊기

연관관계와 탐색 가능성

- Order안에 Shop이라는 인스턴스 변수 박아서 탐색 가능하게.
- **→ 많이 쓰는 방법이 Repository를 쓴다 (약한 결합도)**
- ShopId를 통해서 repository에 보내 shop을 얻을 수 있다.
- repository에 있는 인터페이스를 실제로 repository에 들어갈 인터페이스는 연관관계를 구현할 수 있는 operation들이 들어가줘야한다.
   - 조회 쪽이 섞이면서 깨진다.
   - 조회, admin 로직을 넣다보면 양방향 연관관계가 늘어난다.

어떤 객체들은 묶고 어떤 객체들은 분리할 것인가?

- 도메인 룰이 중요함.
   - 간단한 규칙: 함께 생성되고 함께 삭제되는 객체들을 함께 묶어라.
   - 트랜젝션은 어떤 것이 같이 변경되어야 하고, 어떤 것이 같이 변경되면 안되는지 도메인적으로 묶어 줘야 한다.

간단한 규칙 :

- 함께 생성되고 함께 삭제되는 객체들을 함께 묶어라.
- 도메인 제약 사항을 공유하는 객체들을 함께 묶어라.
- 가능하면 분리하라.

객체를 묶는다.

- 항목에 대한 것을 항목으로 묶는다.
   - constraints나 라이프 사이클 단위로. 생성되는 시점.
- 경계 안의 객체는 참조를 이용해 접근 (연관관계로 묶기)
   - 안 묶을 수 있지만, 묶는게 훨씬 편함.
   - lazy loading, cascade rule 설정 할 수 있음.
- 경계 밖의 객체는 ID를 이용해 접근

→ 그룹을 정하고 그룹 간 객체 참조를 통한 연관관계 제거 → ID를 이용해서 연관관계 설정

만약 Order에서 shop 찾고 싶다 → repository를 통해서 shop을 읽으면 된다.

→ 끊고 나면 객체 단위로 트랜젝션 단위로 묶어 주면된다.

→ 어디부터 어디 까지 가져 와야하는지 판단이 선다.

→ 퍼포먼스 튜닝의 경계가 선다. 어디까지 lazy loading, eager loading 할지 경계가 선다.

일단 참조 없는 객체 그룹으로 나누고 나면

그룹 단위의 영속성 저장소 변경 가능.

하나의 단위로 저장. db 트랜잭션 단위가 된다.

문제점

- id로 바꾸는 순간 부터 컴파일 에러가 발생한다. (validation 로직)
   - → 객체를 직접 참조하는 로직을 다른 객체로 옮기자!
   - → validation 로직 Validator로 옮기 → 응집도가 높아진다.
   - 때로는 절차 지향적인 것이 객체 지향 보다 더 좋다.
- 컴파일에러 2 - 도메인 로직의 순차적 실행
   - 어떤 객체가 바뀔 때 변경 순서의 전후 관계가 있을때, 어떻게 끊냐?
      1. 앞 방법 처럼 절차 지향 로직 (Validator같이)
         1. Service 레이어에서 비즈니스 플로우가 한눈에 보인다는 것이 장점.
      2. 도메인 이벤트 퍼블리싱
         1. Order 바뀔때 delivery, shop도 바뀌어야 하는데, 결합도를 정말 느슨하게 끊고 싶다→ 메모리상에서 객체 만들어서 던지기
         2. Spring Data Aggregate Abstraction 이용
         3. EventHandler 패키지 분리시키
      3. 인터페이스를 이용해서 의존성을 역전 시키자.

정리 하자면

패키지 의존성 해결

1. 중간 객체 만들기
2. 의존성을 인터페이스, 추상클래스로 역전
3. 새로운 패키지로 찢어내기

→ 어떤 것을 쓸지는 판단에 따라 다르다. trade off

→ 이렇게 의존성을 관리하다 보면 시스템을 쉽게 관리할 수 있다.

시스템 이벤트를 통한 시스템 통합

→ 비동기적으로 처리

시스템을 관리할때는 dependency 관점에서 보고 어디서 끊어야 하는지를 명확히 판단하기.