# 1장. 다중 통화를 지원하는 Money 객체

- 통화가 다른 두 금액을 더해서 주어진 환율에 맞게 변한 금액을 결과로 얻을 수 있어야 한다.
- 어떤 금액(주가)을 어떤 수(주식의 수)에 곱한 금액을 결과로 얻을 수 있어야 한다.

객체를 만들면서 시작하는 것이 아니라 테스트를 먼저 만들어야 한다.

위 목록에서 첫 번째는 복잡해 보인다.

작은 것 부터 시작하던, 아예 손을 안대는 것이 좋다.

두 번째부터 하자.

**[목록]**

- $5 X 2 = $10
- amount를 private으로 만들기
- Dollar side effect
- Money 반올림

테스트를 작성할 때는 operation의 완벽한 인터페이스에 대해 상상해보는 것이 좋다.

→ 컴파일 에러 해결하도록 클래스 / 메서드 생성

→ 테스트 실패

→ 당장의 목표는 완벽한 해법을 구하는 것이 아닌 테스트를 통과하는 것.

→ `amount =10;` 달러 객체에서 설정해 테스트만 통과시키기.

→ 일반화.

1. 작은 테스트 하나 추가하기
2. 모든 테스트를 실행해서 테스트가 실패하는 것을 확인한다.
3. 조금 수정한다.
4. 모든 테스트를 실행해서 테스트가 성공하는 것을 확인한다.
5. 중복을 제거하기 위해서 리팩토링한다.

**의존성과 중복**

- 테스트와 코드 간의 문제는 중복이 아니다.
- 문제는 테스트와 코드 사이에 존재하는 **의존성**이다.
  즉 코드나 테스트 중 한쪽을 수정하면 반드시 다른 한쪽도 수정해야만 한다는 것이다.
- 의존성이 문제 그 자체라면 중복은 문제의 징후다.
    - 중복의 가장 흔한 예는 로직의 중복이다.
- 중복된 로직이란 동일한 문장이 코드 여러곳에 나타나는 것을 말한다.
- **중복된 로직을 하나로 끄집어 내는 일엔 객체를 이용하는 것이 최고다.**
- 프로그램에서는 중복만 제거해 주면 의존성도 제거된다.

중복을 제거함으로서 오직 한 가지의 코드 수정을 통해 다음 테스트도 통과되게 만들 가능성을 최대화 해라.

TDD의 핵심은 작은 단계를 밟아야 한다는 것이 아니라, 이런 작은 단계를 밟을 능력을 갖추어야 한다는 것이다.

작은 단계로 작업하는 방법을 배우면, 저절로 적절한 크기의 단계로 작업할 수 있게 된다.

그러나 큰 단계로만 작업했다면 더 작은 단계가 적절한 경우에 대해 결코 알지 못하게 된다.

현재 상황 :

- 우리가 알고 있는 작업해야 할 테스트 목록을 만들었다.
- 오퍼레이션이 외부에서 어떻게 보이길 원하는지 말해주는 이야기를 코드로 표현했다.
- JUnit에 대한 상세한 사항들은 잠시 무시하기로 했다.
- 스텁 구현을 통해 테스트를 컴파일 했다.
- 끔찍한 죄악을 범해 테스트를 통과시켰다.
- 돌아가는 코드에서 상수를 변수로 변경해 점진적으로 일반화 했다.
- 새로운 할일들을 한번에 처리하는 대신 할일 목록에 추가하고 넘어갔다.

**[목록]**

- ~~$5 X 2 = $10~~
- amount를 private으로 만들기
- Dollar side effect
- Money 반올림
```java
public class MoneyTest {

    @Test
    void testMultiplication() {
        Dollar five = new Dollar(5);
        five.times(2);
        assertThat(five.amount).isEqualTo(10);
    }
}
```

```java
public class Dollar {
    int amount;
    public Dollar(int amount) {
        this.amount = amount;
    }

    public void times(int multiplier) {
        amount *= multiplier;
    }
}
```