# 3장. 모두를 위한 평등

지금의 `Dollar` **객체같이 객체를 값 처럼 쓸 수 있는데**, 이것을 **값 객체 패턴 (value object pattern)**이라고 한다.

값 객체에 대한 제약사항 중 하나는 **객체의 인스턴스 변수가 생성자를 통해서 일단 설정된 후에는 결코 변하지 않는다는 것이다.**

값 객체의 또 다른 장점 : 별칭 문제에 대해 걱정할 필요가 없다.

**($5 수표가 영원히 $5임을 보장 받을 수 있다. 변경될 가능성이 없다.)**

값 객체가 암시하는 것

1. 값 객체가 암시하는 것 중 하나는 모든 연산은 새 객체를 반환해야 한다는 것이다.
2. `equals()` 를 구현해야 한다는 것. → `hashCode()` 같이 구현해야 함.

**[목록]**

- $5 + 10CHF = $10 (환율이 2:1인 경우)
- ~~$5 X 2 = $10~~
- amount를 private으로 만들기
- ~~Dollar side effect~~
- Money 반올림
- equals()
- hashCode()

```java
		@Test
    void testEquality() {
        assertThat(new Dollar(5)).isEqualTo(new Dollar(5));
    }
```

위와 같이 테스트를 작성한다.

- 삼각측량 전략:
  만약 라디오 신호 두 수신국이 감지하고 있을 때, 수신국 사이의 거리가 알려져 있고 각 수신국이 신호의 방향을 알고 있다면, 이 정보들만으로 충분히 신호의 거리와 방위를 알 수 있는 것.

→ 예제가 두 개 이상 있어야만 코드를 일반화 할 수 있다.

따라서 두 번째 예제인 $5 ≠ $6을 해보자

```java
@Override
    public boolean equals(Object obj) {
        Dollar dollar = (Dollar) obj;
        return amount == dollar.amount;
    }
```

위와 같이 `equals()` 를 작성한다.

`times()` 를 일반화 할때도 삼각측량을 이용할 수 있었다.

$5 * 2 = $10

$5 * 3 = $15

두 가지가 있었으면 더 이상 상수를 되돌리는 것만으로 테스트를 통과할 방법은 없었을 것이다.

어떨때 삼각측량을 사용해야 하는가?

**→ 리팩토링해야 하는지 전혀 감이 알올 때만 삼각측량을 사용한다.**

**코드와 테스트 사이의 중복을 제거하고 일반적인 해법을 구할 방법이 보이면 그냥 그 방법대로 구현한다.**

하지만 설계를 어떻게 할지 떠오르지 않으면 삼각측량은 문제를 조금 다른 방향에서 생각해 볼 기회를 제공한다.

**[목록]**

- $5 + 10CHF = $10 (환율이 2:1인 경우)
- ~~$5 X 2 = $10~~
- amount를 private으로 만들기
- ~~Dollar side effect~~
- Money 반올림
- ~~equals()~~
- hashCode()
- Equal null
- Equal object

널 값이나 다른 객체와 비교한다면? → 목록 작성

Dollar와 Dollar 직접 비교할 수 있게 됨.

또한 amount를 private로 만들 수 있게 됨.

- 디자인 패턴 (값 객체)이 하나의 또 다른 오퍼레이션을 암시한다는 것을 알아챔
- 해당 오퍼레이션을 테스트 했음
- 해당 오퍼레이션을 간단히 구현했다.
- 곧장 리팩토링하는 대신 테스트를 조금 더 했다.
- 두 경우를 모두 수용할 수 있도록 리팩토링 했다.