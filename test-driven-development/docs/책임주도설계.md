## 객체 지향 패러다임 관점에서의 핵심은?
 - 역할, 책임, 협력
 - 핵심은 **협력**을 구성하기 위해 적절한 객체를 찾고, 적절한 **책임**을 할당하는 과정에서 드러난다.

## 객체 지향 설계 및 구현 접근 방식

### Bottom Up 구현 및 설계
- 설계 역량 부족, 현재 도메인 지식으로는 설계하기가 힘든 상태일 경우
- (1) 구현 -> (2) 설계 개선
 
### Top Down 설계 및 구현
- 앞 단계에서 정교하게 설계 후 구현

위 두 가지 방식 중 정답은 없다. 
선호하는 스타일을 선택하면 된다.

포비는 Bottom Up 방식을 선호하는데, 일정 수준 설계 -> 구현 -> 개선 방식을 따른다.
( 적절히 섞는것이 중요 )

### Bottom Up 
- 일단 구현 후 지속적인 리펙토링
- 객체 설계 어떻게 해야할지 모르겠따면 시작은 클래스, 메서드 구현으로 시작 -> 지속적인 리펙토링
- 리팩토링 할때는 **객체지향 생활체조 원칙**, **클린코드 원칙**을 참고해 리팩토링

### Top Down - 책임 주도 설계
- **책임** : 객체에 의해 정의되는 응집도 있는 행위의 집합
- **객체가 유지해야 하는 정보**와 **수행할 수 있는 행동**에 대해 개략적으로 서술한 문장 **(각각 상태 데이터, 메서드)**
- 즉, 객체가 '무엇을 알고 있는가'와 '무엇을 할 수 있는가'로 구성된다.

하는 것 (메서드) 
- 객체 생성 및 계산 수행 등의 스스로 하는 것
- 다른 객체의 행동을 시작시키는 것
- 다른 객체의 활동을 제어하고 조절 하는 것. (메세지 보내기)

아는 것 (상태)
- 사적인 정보에 관해 아는 것
- 관련된 객체에 대해 아는 것
- 자신이 유도하거나 계산 할 수 있는 것에 관해 아는 것

그래서 책임 주도 설계란?
1. 우선 구현 해야 하는 **책임**을 찾는다.
2. 적절한 객체를 찾아 책임을 할당한다. (클래스 : 책임을 프로그래밍적으로 실행)

과정:
- 시스템 책임 파악
- 더 작은 책임으로 분할
- 적절한 객체 / 역할 찾아 책임 할당
- 객체가 책임 수행 도중 다른 객체 도움 필요한 경우 이를 책임질 적절한 객체 or 역할을 찾는다.
- 해당 객체 or 역할에게 책임 할당 -> 두 객체가 협력

- 구현이 아닌 책임에 집중한다
  - 이유 : 유연하고 견고한 객체 지향.
    - 시스템을 위해 가장 중요한 재료가 바로 책임.


### 자동차 경주 게임 예시

1. 시스템 책임 파악
2. 더작은 책임으로 분리
   - 1. 경주를 하라
     - 2. 이동 가능 여부를 결정하라
     - 3. 이동하라
3. 객체 할당 -> 협력하게 만든다
    - 1. 경주를 하라 -> `Car` 객체의 `race()`
        - 2. 이동 가능 여부를 결정하라 -> `RandomNumGenerator`의 `canMove()`
        - 3. 이동하라 -> `Position`객체의 `move()`
     

역할 : 책임을 찾고 -> 적절한 객체 할당 -> 객체 협력

but 유연하고 재사용 가능한 협력을 얻으려면 "역할" 이라는 개념을 고려해야 한다.

**역할 : 객체가 특정한 협력 안에서 수행하는 책임의 역할**
- 배우 - 배역의 관계를 예로 들 수 있다.
- 서로 다른 배우가 동일한 배역 연기 가능
- 한 배우가 다양한 연극 안에서 서로 다른 배역 연기 가능

**배우: 객체, 배역: 역할, 연극: 협력**

적용해 보자면,
- 서로 다른 객체가 동일한 역할을 할 수 있다. (전략 패턴 예시, 역할 -> 인터페이스 도출)
- 한 객체가 협력 안에서 서로 다른 역할을 할 수 있다.
- 협력이라는 문맥 안에서 역할은 특정한 협력에 참여해서 책임을 수행하는 객체의 일부다.
- 일반적으로 역할은 객체가 협력에 참여하는 잠시 동안에만 존재하는 일시적인 개념이다.

이렇게 객체, 책임, 역할을 찾았다면 다음 단계는 **어떻게 협력할 것인가**
- 의존성을 결정해야 한다.
- 의존성 어떻게 관리 하느냐 따라 유연한 설계 여부가 달라진다.
  - compile time 의존성 -> 테스트 하기 어려움
  - Runtime 의존성 -> 테스트 하기 쉬움 (동적 바인딩) -> 유연한 코드 만들어 지는 '경향'이 있음.

이렇게 DI, DIP는 Spring과 무관함.

Spring 등장 전 부터 유연한 코드 만들기 위한 원칙 중 하나임.
- 수월하게 해 주는 것이 Spring이다. (IOC container -> DI 해줌.)

- 유연한 설계 지향한다면 컴파일 -> 런타임 의존성으로 대체 -> 테스트 쉬워짐 -> 유연한 설계 가능해지는 경험

책임 주도 설계 == 인터페이스 주도 설계

책임 -> 인터페이스로 뽑기
- 주의할 점 : 패키지 간 Cyclic dependency가 생겼을 때 끊을 수 없는 경우가 있다.
- 중간 연결 시켜주는 또 다른 package가 필요하다 (factory)
- 이것을 원래 spring 에서 DI container가 하는 것. interface 구현체들은 서로 조합해 연결시켜주는 역할.
- **패키지 간 참조는 단방향으로 가질 수 있게 설계하기**
  - cyclic dependency -> DDD 기반 개발 할 때도 분리하기 힘들다.
    - MSA 갈때도 쪼개기가 힘들다. (분리하기가 힘듦)

- 패키지 간 의존 관계는 단방향!
  - **`sonarqube`같은 정적 분석 도구를 활용해 cyclic dependencies 찾는 것이 가장 중요**
  - CI 도구 연결 해 매일 reporting 통해 bug report 보는 것으로 하루를 시작.
  - clean code를 지향 한다면 실무에서 반드시 도입하기. 
